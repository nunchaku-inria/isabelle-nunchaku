(*  Title:      HOL/Tools/Nunchaku/nunchaku_tool.ML
    Author:     Jasmin Blanchette, Inria Nancy, LORIA, MPII
    Copyright   2015

Interface to the external "nunchaku" tool.
*)

signature NUNCHAKU_TOOL =
sig
  type ty = Nunchaku_Problem.ty
  type tm = Nunchaku_Problem.tm
  type nun_problem = Nunchaku_Problem.nun_problem

  type tool_params =
    {overlord: bool,
     debug: bool}

  type nun_solution =
    {tys: (ty * tm list) list,
     tms: (tm * tm) list}

  datatype nun_outcome =
    Unsat
  | Sat of string * nun_solution
  | Timed_Out
  | Nunchaku_Not_Found
  | CVC4_Not_Found
  | Unknown_Error

  val nunchaku_env_var: string

  val solve_nun_problem: tool_params -> nun_problem -> nun_outcome
end;

structure Nunchaku_Tool : NUNCHAKU_TOOL =
struct

open Nunchaku_Util;
open Nunchaku_Problem;

type tool_params =
  {overlord: bool,
   debug: bool};

type nun_solution =
  {tys: (ty * tm list) list,
   tms: (tm * tm) list};

datatype nun_outcome =
  Unsat
| Sat of string * nun_solution
| Timed_Out
| Nunchaku_Not_Found
| CVC4_Not_Found
| Unknown_Error;

val nunchaku_env_var = "NUNCHAKU";

val cached_outcome =
  Synchronized.var "Nunchaku_Tool.cached_outcome" (NONE : (nun_problem * nun_outcome) option);

fun uncached_solve_nun_problem overlord prob =
  with_tmp_or_overlord_file overlord "nunchaku" "nun" (fn prob_path =>
    let
      val bash_cmd = "\"$" ^ nunchaku_env_var ^ "\" " ^ File.shell_path prob_path;
      val comments =
        [bash_cmd, "This file was generated by Isabelle (most likely Nunchaku)", timestamp ()];
      val prob_str = cat_lines (map (prefix "# ") comments) ^ "\n\n" ^ str_of_nun_problem prob;
      val _ = File.write prob_path prob_str;
      val (output, code) = Isabelle_System.bash_output bash_cmd;
    in
      if String.isPrefix "SAT" output then Sat (output, {tys = [], tms = []})
      else if String.isPrefix "UNSAT" output then Unsat
      else Unknown_Error
    end);

fun solve_nun_problem {overlord, debug} prob =
  let
    fun solve_now () =
      uncached_solve_nun_problem overlord prob;
  in
    if overlord orelse debug then
      solve_now ()
    else
      (case AList.lookup (op =) (the_list (Synchronized.value cached_outcome)) prob of
        SOME outcome => outcome
      | NONE =>
        let
          val outcome = solve_now ();

          fun update_cache () =
            Synchronized.change cached_outcome (K (SOME (prob, outcome)));
        in
          (case outcome of
            Unsat => update_cache ()
          | Sat _ => update_cache ()
          | _ => ());
          outcome
        end)
  end;

end;
